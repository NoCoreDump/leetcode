题目描述：链表中删除重复节点
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ListNode deleteDuplication(ListNode pHead)
    {
        if (pHead == null || pHead.next == null) return pHead;
        ListNode h = pHead;
        if (h.val == h.next.val) { //头节点重复
            ListNode tmp = null;
            while (pHead != null && pHead.val == h.val) {
                tmp = pHead;
                pHead = pHead.next;
            }
            if (pHead == null) return null; //所有节点都相等
            tmp.next = null;
            return (deleteDuplication(pHead));
        }
        h.next = deleteDuplication(pHead.next);//递归删除重复节点
        return h;
    }
}

题目描述：重建二叉树
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    int[] pre, in;
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        this.pre = pre;
        this.in = in;
        if (pre.length == 0) return null;
        TreeNode root = help(0, pre.length-1, 0, pre.length-1);
        return root;
    }
    //根据二叉树的特点重建，根据先序遍历的根节点将对应的中序遍历分为两半，
    //中序遍历前半部分是左子树，后半部分是右子树；递归调用
    public TreeNode help(int i, int j, int m, int n) {
        TreeNode node = null;
        if (j >= pre.length || n >= pre.length) return null;
        if (i < 0 || m < 0) return null;
        for (int k = m; k <= n; k++){
            if (pre[i] == in[k]) {
                node = new TreeNode((pre[i]));
                node.left = help(i+1, i+k-m, m, k-1);
                node.right = help(i+k-m+1,j,k+1,n);
                break;
            }
        }
        return node;
    }
}

题目描述
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();

    public void push(int node) {
        stack1.push(node);
    }

    public int pop() {
        if (!stack2.isEmpty()) return stack2.pop();  //stack2不为空，直接弹出栈顶元素
        while (!stack1.isEmpty()) {  //stack2为空，将stack1的数据逆向复制到stack2
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }
}

题目描述
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。


//方法一：顺序遍历，比第一个值小的即为最小值，特殊情况：数组所有值都相等、旋转数组为数组本身，最小值为第一个数。
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if (array.length == 0) return 0;
        for (int i = 1; i < array.length; i++) {
            if (array[i] < array[0]) return array[i];
        }
        return array[0];
    }
}
//方法二：二分法查找（逻辑复杂，运行效率并没有明显提升，或许是因为测试用例太少？数组长度还不够长？）
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if (array.length == 0) return 0;
        if (array[0] < array[array.length -1]) return array[0];  //旋转数组为本身
        //二分法查找
        int index1 = 0;
        int index2 = array.length - 1;
        int midIndex = 0;
        while (array[index1] >= array[index2]) {
            if (index2 - 1 == index1) {
                midIndex = index2;
                break;
            }
            midIndex = (index1 + index2) / 2;
            //左中右皆相等，顺序遍历
            if (array[index1] == array[index2] && array[index1] == array[midIndex]) {
                for (int i = index1; i <= index2; i++) {
                    if (array[i] < array[index1]) return array[i];
                }
            }
            //缩小一半范围
            if (array[midIndex] >= array[index1]) {
                index1 = midIndex;
            } else if (array[midIndex] <= array[index2]) {
                index2 = midIndex;
            }
        }

        return array[midIndex];
    }
}

题目描述
我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
比如n=3时，2*3的矩形块有3种覆盖方法
解题思路：求斐波那契数列，代码略

题目描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
//实际上是求斐波那契数列，f(1) = 1; f(2) = 2; f(n)=f(n-1)+f(n-2)
//当青蛙一次可以跳上1级、2级......n级的时候，f(n)=2^(n-1);
public class Solution {
    public int JumpFloor(int target) {
        if (target <= 1) return 1;
        if (target == 2) return 2;

        int[] dp = new int[target];
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 2; i < target; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[target-1];
    }
}
题目描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
public class Solution {
    public int JumpFloorII(int target) {
        if (target== 1) return 1;
        if (target== 2) return 2;
        return pow(2, target-1);
    }

    //整数的幂函数
    public int pow(int base, int e) {
        if (base == 0) return 0;
        if (e == 0) return 1;
        if (e == 1) return  base;
        if (e == 2) return base * base;
        if (e % 2 == 1) {
            int result = pow(base, (e-1)/2);
            return base * result * result;
        } else {
            int result = pow(base, e/2);
            return result * result;
        }
    }
}

题目描述
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
保证base和exponent不同时为0
public class Solution {
    public double Power(double base, int exponent) {
        double res;
        if (exponent == 0) return 1;
        else if (exponent > 0) {
            res = Power(base, (exponent/2));
            return (exponent % 2 == 0) ? (res * res) : (res * res * base);
        } else {
            if (base == 0) return 0;
            exponent = Math.abs(exponent);
            res = Power(base, exponent);
            return 1 / res;
        }
  }
}

题目描述
输入一个链表，反转链表后，输出新链表的表头。
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode h, p;
        h = head.next;
        head.next = null;
        while (h.next != null) {
            p = h.next;
            h.next = head;
            head = h;
            h = p;
        }
        h.next = head;
        return h;
    }
}

题目描述
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
/*
public class ListNode {
    int val;
    ListNode next = null;
    ListNode(int val) {
        this.val = val;
    }
}*/
//迭代法
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode p;
        if (list1 == null) return list2;
        if (list2 == null) return list1;
        p = list1;
        if (list2.val < list1.val) { //list1指向头节点较小的链表
            list1 = list2;
            list2 = p;
        }
        p = list1;
        while (p!= null && list2 != null) {
            while (p.next != null && p.next.val <= list2.val) {
                p = p.next;
            }
            ListNode tmp = p.next;
            p.next = list2;
            list2 = tmp;
        }
        return list1;
    }
}
//递归
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if (list1 == null) return list2;
        if (list2 == null) return list1;
        if (list1.val <= list2.val) {
            list1.next = Merge(list1.next, list2);
            return list1;
        } else {
            list2.next = Merge(list2.next, list1);
            return list2;
        }
    }
}

题目描述
从上往下打印出二叉树的每个节点，同层节点从左至右打印。
import java.util.ArrayList;
import java.util.ArrayDeque;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<>();
        if (root == null) return res;
        ArrayDeque<TreeNode> stack = new ArrayDeque<>();
        stack.add(root);
        while (!stack.isEmpty()) {
            int count = stack.size();
            while (count -- > 0) {
                TreeNode node = stack.poll();
                res.add(node.val);
                if (node.left != null) stack.add(node.left);
                if (node.right != null) stack.add(node.right);
            }
        }
        return res;
    }
}

题目描述
输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
public class Solution {
    public int TreeDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(TreeDepth(root.left), TreeDepth(root.right)) + 1;
    }
}

题目描述
操作给定的二叉树，将其变换为源二叉树的镜像。
输入描述:
二叉树的镜像定义：源二叉树
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
public class Solution {
    public void Mirror(TreeNode root) {
        if (root == null) return;
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        Mirror(root.left);
        Mirror(root.right);
    }
}

题目描述
请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
//迭代法
public class Solution {
    boolean isSymmetrical(TreeNode pRoot)
    {
        if (pRoot == null) return true;
        return isSame(pRoot.left, pRoot.right);
    }
    boolean isSame(TreeNode t1, TreeNode t2) {
        if (t1 == null && t2 == null) return true;
        if (t1 == null || t2 == null) return false;
        if (t1.val != t2.val) return false;
        Queue<TreeNode> queue1 = new LinkedList<>();
        Queue<TreeNode> queue2 = new LinkedList<>();
        queue1.add(t1);
        queue2.add(t2);
        while (!queue1.isEmpty() && !queue2.isEmpty()) {
            int cnt1 = queue1.size();
            int cnt2 = queue2.size();
            if (cnt1 != cnt2) return false;
            while (cnt1 -- > 0 && cnt2 -- > 0) {
                TreeNode node1 = queue1.poll();
                TreeNode node2 = queue2.poll();
                if (node1.val != node2.val) return false;
                if (node1.left != null) {
                    if (node2.right == null) return false;
                    queue1.add(node1.left);
                    queue2.add(node2.right);
                } else if (node2.right != null) return false;

                if (node1.right != null) {
                    if (node2.left == null) return false;
                    queue1.add(node1.right);
                    queue2.add(node2.left);
                } else if (node2.left != null) return false;
            }
        }
        return true;
    }
}

//递归
boolean isSymmetrical(TreeNode pRoot) {
    if (pRoot == null)
        return true;
    return isSymmetrical(pRoot.left, pRoot.right);
}
boolean isSymmetrical(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null)
        return true;
    if (t1 == null || t2 == null)
        return false;
    if (t1.val != t2.val)
        return false;
    return isSymmetrical(t1.left, t2.right) && isSymmetrical(t1.right, t2.left);
}

题目描述
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
//Integer.bitCount(n);
public class Solution {
    public int NumberOf1(int n) {
        int cnt = 0;
        while (n != 0) {
            cnt++;
            n = (n - 1) & n;
        }
        return cnt;
    }
}

树的子结构
题目描述
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if (root1 == null || root2 == null) return false;
        if (root1.val == root2.val && isSub(root1, root2))
            return true;
        return HasSubtree(root1.left, root2) | HasSubtree(root1.right, root2);
    }
    boolean isSub(TreeNode t1, TreeNode t2) {  //子结构不是子树
        if (t2 == null) return true;
        if (t1 == null) return false;
        if (t1 != null && t1.val != t2.val)
            return false;
        return isSub(t1.left, t2.left) && isSub(t1.right, t2.right);
    }
}

判断序列是否为二叉搜索树的后序遍历
题目描述
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
public class Solution {
    //先根据根节点将序列划分为左右子树，然后递归判断
    public boolean VerifySquenceOfBST(int [] sequence) {
        if (sequence.length == 0) return false;
        return help(sequence, 0, sequence.length - 1);
    }
    public boolean help(int[] sequence, int start, int end) {
        if (end - start <= 1) return true;
        int root = sequence[end];
        int index = -1;
        boolean flag = false;
        for (int i = 0; i <= end; i++) {
            if (!flag && sequence[i] > root) {
                index = i;
                flag = true;
            }
            if (flag && sequence[i] < root) return false;
        }
        if (index <= 0) return help(sequence, start, end - 1);
        else return help(sequence, start, index - 1) & help(sequence, index, end - 1);
    }
}

链表倒数第k个节点
题目描述
输入一个链表，输出该链表中倒数第k个结点。
//双指针法
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if (head == null || k <= 0) return null;
        ListNode p, q;
        p = q = head;
        while (p != null && k-- > 0) {
            p = p.next;
        }
        if (k > 0) return null;
        while (p != null) {
            p = p.next;
            q = q.next;
        }
        return q;
    }
}

二叉树中和为给定值的路径
题目描述
输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
public class Solution {
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        TreeNode h = root;
        ArrayList<Integer> list = new ArrayList<>();
        helper(root, target, list, res);
        return res;
    }
    public void helper(TreeNode root, int target, ArrayList<Integer> list, ArrayList<ArrayList<Integer>> res) {
        if (root == null || root.val > target) {
            return;
        }
        list.add(root.val);
        target = target - root.val;
        if (target == 0 && root.left == null && root.right == null) {
            ArrayList<Integer> l = new ArrayList<>(list.size());
            l = (ArrayList<Integer>)list.clone();
            res.add(l);
        } else {
            helper(root.left, target, list, res);
            helper(root.right, target, list, res);
        }
        list.remove(list.size()-1);
    }
}

复杂链表的复制
题目描述
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。
（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
/*
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
*/
public class Solution {
    public RandomListNode Clone(RandomListNode pHead)
    {
        if (pHead == null) return pHead;
        RandomListNode head, cur;
        //再每个节点后面复制它本身
        cur = pHead;
        while (cur != null) {
            RandomListNode node = new RandomListNode(cur.label);
            node.next = cur.next;
            cur.next = node;
            cur = node.next;
        }
        //复制random
        cur = pHead;
        while (cur != null) {
            RandomListNode p = cur.next;
            if (cur.random!= null) p.random = cur.random.next;
            cur = p.next;
        }
        //拆分
        cur = pHead;
        head = pHead.next;
        while (cur.next != null) {
            RandomListNode p = cur.next;
            cur.next = p.next;
            cur = p;
        }
        return head;
    }
}

字符串的排列
题目描述
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
输入描述:
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
import java.util.*;
public class Solution {
    public ArrayList<String> Permutation(String str) {
        ArrayList<String> res = new ArrayList<>();
        if (str.length() == 0) return res;
        char[] charArr = str.toCharArray();
        Arrays.sort(charArr);
        StringBuilder sb = new StringBuilder();
        boolean[] used = new boolean[charArr.length];
        dfs(charArr, sb, used, res);
        return res;
    }
    public void dfs(char[] arr, StringBuilder sb, boolean[] used, ArrayList<String> res) {
        if (sb.length() == arr.length) {
            res.add(sb.toString());
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            if (used[i]) {
                continue;
            }
            if (i != 0 && arr[i] == arr[i - 1] && !used[i - 1]) /* 保证不重复 */
                continue;
            sb.append(arr[i]);
            used[i] = true;
            dfs(arr, sb, used,res);
            sb.deleteCharAt(sb.length()-1);
            used[i] = false;
        }
    }
}

数组中出现次数超过一半的数字
题目描述
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。
由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
import java.util.Arrays;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        if (array.length == 0) return 0;
        int res = 0;
        int n = array.length / 2;

        //使用Arrays.sort排序的做法
        //Arrays.sort(array);
        /*int i = 0;
        while (i < array.length - n) {
        if (array[i] == array[i+n]) {
            res = array[i];
            return res;
        } else {
            i++;
        }
    }*/

        //使用计数排序
        int min = 99999;
        int max = -9999;
        for (int a : array) {
            min = Math.min(min, a);
            max = Math.max(max, a);
        }
        int[] table = new int[max-min+1];
        for (int a : array) {
            table[a-min]++;
        }
        for (int i = 0; i < table.length; ++i) {
            if (table[i] > n) {
                res = i + min;
                break;
            }
        }
        return res;
    }
}

数组中最小的k个数
题目描述
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
import java.util.*;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        if (input.length == 0 || k <= 0 || k > input.length) return new ArrayList<Integer>();
        Queue<Integer> q = new PriorityQueue<>(input.length);
        for (int i : input) {
            q.add(i);

        }
        ArrayList<Integer> res = new ArrayList<>();
        while (!q.isEmpty() && k-- > 0) {
            res.add(q.poll());
        }
        return res;
    }
}

//大顶堆
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Comparator;
public class Solution {
   public ArrayList<Integer> GetLeastNumbers_Solution(int[] input, int k) {
       ArrayList<Integer> result = new ArrayList<Integer>();
       int length = input.length;
       if(k > length || k == 0){
           return result;
       }
        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(k, new Comparator<Integer>() {

            @Override
            public int compare(Integer o1, Integer o2) {
                return o2.compareTo(o1);
            }
        });
        for (int i = 0; i < length; i++) {
            if (maxHeap.size() != k) {
                maxHeap.offer(input[i]);
            } else if (maxHeap.peek() > input[i]) {
                Integer temp = maxHeap.poll();
                temp = null;
                maxHeap.offer(input[i]);
            }
        }
        for (Integer integer : maxHeap) {
            result.add(integer);
        }
        return result;
    }
}

连续子数组的最大和
题目描述
HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？
例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。
//动态规划，dp[i]表示以第i个元素为终点的连续子向量的最大和值
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        int n = array.length;
        if (n == 0) return 0;
        int max = array[0];
        int[] dp = new int[array.length];
        dp[0] = max;
        for (int i = 1; i < n; ++i) {
            dp[i] = Math.max(dp[i-1] + array[i], array[i]);
            max = Math.max(max, dp[i]);
        }
        return max;
    }
}

两个链表的第一个公共节点
题目描述
输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        if (pHead1 == null || pHead2 == null) return null;
        ListNode p;
        int len1 = 0;
        int len2 = 0;
        p = pHead1;
        while (p != null) {
            p = p.next;
            len1++;
        }
        p = pHead2;
        while (p != null) {
            p = p.next;
            len2++;
        }
        int c = len1 - len2;
        if (c > 0) {
            while (c-- > 0) {
                pHead1 = pHead1.next;
            }
        } else {
            c = Math.abs(c);
            while (c-- > 0) {
                pHead2 = pHead2.next;
            }
        }
        while (pHead1 != null && pHead2 != null) {
            if (pHead1 == pHead2) return pHead1;
            else {
                pHead1 = pHead1.next;
                pHead2 = pHead2.next;
            }
        }
        return null;
    }
}

第一个只出现一次的字符
题目描述
在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.
public class Solution {
    public int FirstNotRepeatingChar(String str) {
        if (str.length() == 0) return -1;
        int[] table = new int[26];
        int[] Table = new int[26];
        char[] charArr = str.toCharArray();
        for (char c : charArr) {
            if (c <= 'z' && c >= 'a')
                table[c-'a']++;
            else
                Table[c-'A']++;
        }
        for (int i = 0; i < charArr.length; i++) {
            if (charArr[i] >= 'a' && charArr[i] <= 'z' && table[charArr[i]-'a'] == 1) return i;
            if (charArr[i] >= 'A' && charArr[i] <= 'Z' && Table[charArr[i]-'A'] == 1) return i;
        }
        return -1;
    }
}

数字在排序数组中出现的次数
题目描述
统计一个数字在排序数组中出现的次数。
import java.util.*;
public class Solution {
    public int GetNumberOfK(int [] array , int k) {
        if (array.length == 0) return 0;
        int index = Arrays.binarySearch(array, k);
        if (index < 0) return 0;
        int res = 1;
        for (int i = index - 1; i >= 0; --i) {
            if (array[i] == k) res++;
        }
        for (int i = index + 1; i < array.length; ++i) {
            if (array[i] == k) res++;
        }
        return res;
    }
}

平衡二叉树
题目描述
输入一棵二叉树，判断该二叉树是否是平衡二叉树。
//通过页子节点的最大、最小深度的差值进行判断
public class Solution {
    int maxDep = 0;
    int minDep = 9999;
    boolean res = true;
    public boolean IsBalanced_Solution(TreeNode root) {
        if (root == null) return true;
        dfs(root.left, 1);
        dfs(root.right, 1);
        return res;
    }
    public void dfs(TreeNode root, int d) {
        if (res == false) return;
        if (root == null) {
            maxDep = Math.max(maxDep, d);
            minDep = Math.min(minDep, d);
            if (maxDep - minDep > 1) {
                res = false;
                return;
            }
            return;
        }
        if (root.left == null && root.right == null) {
            maxDep = Math.max(maxDep, d + 1);
            minDep = Math.min(minDep, d + 1);
            if (maxDep - minDep > 1) {
                res = false;
                return;
            }
        }
        if (root.left != null) dfs(root.left, d+1);
        if (root.right != null) dfs(root.right, d+1);
    }
}
//通过递归比较左右子树的高度进行判断
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if (root == null) {
            return true;
        }
        int l = helper(root.left);
        int r = helper(root.right);
        if (l == -1 || r == -1 || Math.abs(l - r) > 1)
            return false;
        return true;
    }
    public int helper(TreeNode root) {  //如果不平衡，返回-1，否则返回子树的高度
        if (root == null)
            return 0;
        int l = helper(root.left);
        int r = helper(root.right);
        if (l == -1 || r == -1 || (Math.abs(l - r) > 1))
            return -1;
        return Math.max(l, r) + 1;
    }
}

把数组排成最小的数
题目描述
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
//使用基数排序的思想
import java.util.ArrayList;
import java.util.*;
public class Solution {
    public String PrintMinNumber(int [] numbers) {
        return fun(numbers);
    }
    public static String fun(int[] nums) {
        StringBuilder sb = new StringBuilder();
        Integer[] arr = new Integer[nums.length];
        for (int i = 0; i < nums.length; ++i) {
            arr[i] = new Integer(nums[i]);
        }
        baseSort(arr);
        for (int n : arr) {
            sb.append(n);
        }
        return sb.toString();
    }
    public static void baseSort(Integer[] nums) {
        Arrays.sort(nums, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                String s1 = String.valueOf(o1);
                String s2 = String .valueOf(o2);
                for (int i = 0; i < Math.max(s1.length(), s2.length()); ++i) {
                    char c1, c2;
                    if (i >= s1.length()) c1 = s1.charAt(0);
                    else c1 = s1.charAt(i);
                    if (i >= s2.length()) c2 = s2.charAt(0);
                    else c2 = s2.charAt(i);
                    if (c1 != c2) return c1 - c2;
                }
                return 0;
            }
        });
    }
}

丑数
题目描述
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if (index <= 6) return index;
        int i2 = 0, i3 = 0, i5 = 0;
        int[] dp = new int[index];
        dp[0] = 1;
        for (int i = 1; i < index ; i++) {
            int next2 = dp[i2] * 2, next3 = dp[i3] * 3, next5 = dp[i5] * 5;
            dp[i] = Math.min(next2, Math.min(next3, next5));
            if (dp[i] == next2)
                i2++;
            if (dp[i] == next3)
                i3++;
            if (dp[i] == next5)
                i5++;
        }
        return dp[index-1];
    }
}