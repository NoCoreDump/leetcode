1. 判断两个树的叶子节点序列是否相等。
思路：dfs.分别求出两棵树的叶子值序列，再进行比较。
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        List<Integer> seq1 = new LinkedList<>();
        List<Integer> seq2 = new LinkedList<>();
        preOrder(root1, seq1);
        preOrder(root2, seq2);
        if (seq1.size() != seq2.size()) return false;
        for (int i = 0; i < seq1.size(); i++) {
            if (seq1.get(i) != seq2.get(i)) return false;
        }
        return true;
        
    }
    public void preOrder(TreeNode root, List<Integer> seq) {
        if (root == null) return;
        if (root.left == null && root.right == null) {
            seq.add(root.val);
        }
        preOrder(root.left, seq);
        preOrder(root.right, seq);
    }
}

leetcode104. Maximum Depth of Binary Tree
思路：递归dfs.根节点的最大深度 = max(左孩子的最大深度，右孩子的最大深度）+ 1；
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int depth = 1;
        return depth+Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}

1022. Sum of Root To Leaf Binary Numbers
思路：回溯法。
用一个list存访问过的节点值，先访问左子树，再访问右子树；
访问到叶子节点，根据list计算整数值并加到全局变量sum中，然后list删除最后一位（即回退一步）并返回；
右子树访问完list再删除最后一位（容易忽略）。
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int sum = 0;
    public int sumRootToLeaf(TreeNode root) {

        if (root == null) return 0;
        dfs(root, new LinkedList());
        return sum;
    }
    public void dfs(TreeNode root, LinkedList<Integer> list) {
        if (root == null)return;
        list.add(root.val);
        if (root.left == null && root.right == null) {
            sum += toInt(list);
            // System.out.println(sum);
            list.removeLast();
            return;
        }
        dfs(root.left, list);
        dfs(root.right, list);
        if (list.size() > 0) list.removeLast();
    }
    public int toInt(List<Integer> list) {
        int i = 0; 
        int val = 0;
        for (int n : list) {
            val = 2 * val + n;
        }
        return val;
    }
}

669. Trim a Binary Search Tree
思路：递归dfs.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
   public TreeNode trimBST(TreeNode root, int L, int R) {
        if(root == null) return null; // Base case
        /*
        * If current node is greater than the Right limit, we will skip this one
        * try to append its left child to the current position
        * Or current is smaller than the Left limit, skip this one, and try to 
        * append its right child to the current position
        */
        if(root.val > R) return trimBST(root.left, L, R); 
        if(root.val < L) return trimBST(root.right, L, R);
        /*
        * Recursively, check current node's left child and right child if they are trimBST subtree already.
        */
        root.left = trimBST(root.left, L, R);
        root.right = trimBST(root.right, L, R);
        // Return the current Node;
        return root;
    }
}

429. N-ary Tree Level Order Traversal
思路：采用一个队列和一个计数器；计数器的值为当前层的节点数；
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val,List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        
        List<List<Integer>> ans = new LinkedList<>();
        Queue<Node> queue = new ArrayDeque<>();
        if (root == null) return ans;
        queue.add(root);
        while (!queue.isEmpty()) {
            int count = queue.size();
            List<Integer> list = new LinkedList<>();
            while (count -- > 0) {
                Node node = queue.poll();
                list.add(node.val);
                for (Node n : node.children) {
                    if (n!= null) queue.add(n);
                }
                
            }
            ans.add(list);
        }
        return ans;
    }
}

226. Invert Binary Tree
思路：递归交换左右子树，套路与669题相似
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;
        TreeNode left = root.left;
        root.left = invertTree(root.right);
        root.right = invertTree(left);
        return root;
    }
}

637. Average of Levels in Binary Tree
思路：层次遍历
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
       List<Double> ans = new LinkedList<>();
        if (root == null) return ans;
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int count = queue.size();
            int i = count;
            double sum = 0;
            while (i -- > 0) {
                TreeNode node = queue.poll();
                sum += (double)node.val;
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
                
            }
            ans.add(sum / count);
        }
        return ans;
    }
    
}

653. Two Sum IV - Input is a BST
思路：1.对树进行中序遍历得到一个有序数组，用双指针来求和；96ms
     2.对树遍历的时候用map存已遍历过得值，在添加之前进行查询；4ms
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
 
 //双指针法
class Solution {
    List<Integer> list;
    public boolean findTarget(TreeNode root, int k) {
        if (root == null) return false;
        list = new LinkedList<>();
        inOrder(root);
        return isFind(k, list, 0, list.size() - 1);
    }
    public void inOrder(TreeNode root) {
        if (root == null) return;
        inOrder(root.left);
        list.add(root.val);
        inOrder(root.right);
    }
    public boolean isFind(int k, List<Integer> list, int from, int to) {
        int left = from;
        int right = to;
        while (left < right) {
            
            if (list.get(right) == k - list.get(left)) return true;
            while (left < right && list.get(right) > k - list.get(left)) right--;
            if (list.get(right) < k - list.get(left)) {
                left++;
            }
        }
        return false;
    }
}

//hashmap法
class Solution {
    Set<Integer> set;
    public boolean findTarget(TreeNode root, int k) {
        set = new HashSet<>();
        return helper(root, k);
    }
    
    boolean helper(TreeNode root, int target){
        if(root == null) {
            return false;
        }
        
        if(set.contains(target-root.val)){
            return true;
        }
        set.add(root.val);
        return helper(root.left, target) || helper(root.right, target);
    }
}

108. Convert Sorted Array to Binary Search Tree
思路：二分法；维护数组区间的左右下标，每次取当前区间的中间值作为当前节点值，其左子树从左半边区间取，右子树从右半边区间取，修改区间下标，进行递归。
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums.length == 0) return null;
        return helper(nums, 0, nums.length - 1);
    }
    public TreeNode helper(int[] nums, int L, int R) {
        if (L > R) return null;
        int mid = (L + R) >> 1;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = helper(nums, L, mid - 1);
        node.right = helper(nums, mid + 1, R);
        return node;
    }
}

538. Convert BST to Greater Tree
思路：中序遍历，从最大值开始，用一个全局变量curr记录当前遍历的值的和。每次遍历时，将节点值与curr的和赋给当前节点，然后更新curr；
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int curr = 0;
    public TreeNode convertBST(TreeNode root) {
        
        if (root == null) return null;
        helper(root);
        return root;
        
    }
    public void helper(TreeNode root) {
        if (root == null) return;
        helper(root.right);
        root.val += curr;
        curr = root.val;
        helper(root.left);
    }
}
