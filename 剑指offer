题目描述：链表中删除重复节点
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ListNode deleteDuplication(ListNode pHead)
    {
        if (pHead == null || pHead.next == null) return pHead;
        ListNode h = pHead;
        if (h.val == h.next.val) { //头节点重复
            ListNode tmp = null;
            while (pHead != null && pHead.val == h.val) {
                tmp = pHead;
                pHead = pHead.next;
            }
            if (pHead == null) return null; //所有节点都相等
            tmp.next = null;
            return (deleteDuplication(pHead));
        }
        h.next = deleteDuplication(pHead.next);//递归删除重复节点
        return h;
    }
}

题目描述：重建二叉树
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    int[] pre, in;
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        this.pre = pre;
        this.in = in;
        if (pre.length == 0) return null;
        TreeNode root = help(0, pre.length-1, 0, pre.length-1);
        return root;
    }
    //根据二叉树的特点重建，根据先序遍历的根节点将对应的中序遍历分为两半，
    //中序遍历前半部分是左子树，后半部分是右子树；递归调用
    public TreeNode help(int i, int j, int m, int n) {
        TreeNode node = null;
        if (j >= pre.length || n >= pre.length) return null;
        if (i < 0 || m < 0) return null;
        for (int k = m; k <= n; k++){
            if (pre[i] == in[k]) {
                node = new TreeNode((pre[i]));
                node.left = help(i+1, i+k-m, m, k-1);
                node.right = help(i+k-m+1,j,k+1,n);
                break;
            }
        }
        return node;
    }
}

题目描述
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();

    public void push(int node) {
        stack1.push(node);
    }

    public int pop() {
        if (!stack2.isEmpty()) return stack2.pop();  //stack2不为空，直接弹出栈顶元素
        while (!stack1.isEmpty()) {  //stack2为空，将stack1的数据逆向复制到stack2
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }
}

题目描述
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。


//方法一：顺序遍历，比第一个值小的即为最小值，特殊情况：数组所有值都相等、旋转数组为数组本身，最小值为第一个数。
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if (array.length == 0) return 0;
        for (int i = 1; i < array.length; i++) {
            if (array[i] < array[0]) return array[i];
        }
        return array[0];
    }
}
//方法二：二分法查找（逻辑复杂，运行效率并没有明显提升，或许是因为测试用例太少？数组长度还不够长？）
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if (array.length == 0) return 0;
        if (array[0] < array[array.length -1]) return array[0];  //旋转数组为本身
        //二分法查找
        int index1 = 0;
        int index2 = array.length - 1;
        int midIndex = 0;
        while (array[index1] >= array[index2]) {
            if (index2 - 1 == index1) {
                midIndex = index2;
                break;
            }
            midIndex = (index1 + index2) / 2;
            //左中右皆相等，顺序遍历
            if (array[index1] == array[index2] && array[index1] == array[midIndex]) {
                for (int i = index1; i <= index2; i++) {
                    if (array[i] < array[index1]) return array[i];
                }
            }
            //缩小一半范围
            if (array[midIndex] >= array[index1]) {
                index1 = midIndex;
            } else if (array[midIndex] <= array[index2]) {
                index2 = midIndex;
            }
        }

        return array[midIndex];
    }
}

题目描述
我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
比如n=3时，2*3的矩形块有3种覆盖方法
解题思路：求斐波那契数列，代码略

题目描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
//实际上是求斐波那契数列，f(1) = 1; f(2) = 2; f(n)=f(n-1)+f(n-2)
//当青蛙一次可以跳上1级、2级......n级的时候，f(n)=2^(n-1);
public class Solution {
    public int JumpFloor(int target) {
        if (target <= 1) return 1;
        if (target == 2) return 2;

        int[] dp = new int[target];
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 2; i < target; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[target-1];
    }
}
题目描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
public class Solution {
    public int JumpFloorII(int target) {
        if (target== 1) return 1;
        if (target== 2) return 2;
        return pow(2, target-1);
    }

    //整数的幂函数
    public int pow(int base, int e) {
        if (base == 0) return 0;
        if (e == 0) return 1;
        if (e == 1) return  base;
        if (e == 2) return base * base;
        if (e % 2 == 1) {
            int result = pow(base, (e-1)/2);
            return base * result * result;
        } else {
            int result = pow(base, e/2);
            return result * result;
        }
    }
}

题目描述
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
保证base和exponent不同时为0
public class Solution {
    public double Power(double base, int exponent) {
        double res;
        if (exponent == 0) return 1;
        else if (exponent > 0) {
            res = Power(base, (exponent/2));
            return (exponent % 2 == 0) ? (res * res) : (res * res * base);
        } else {
            if (base == 0) return 0;
            exponent = Math.abs(exponent);
            res = Power(base, exponent);
            return 1 / res;
        }
  }
}

题目描述
输入一个链表，反转链表后，输出新链表的表头。
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode h, p;
        h = head.next;
        head.next = null;
        while (h.next != null) {
            p = h.next;
            h.next = head;
            head = h;
            h = p;
        }
        h.next = head;
        return h;
    }
}

题目描述
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
/*
public class ListNode {
    int val;
    ListNode next = null;
    ListNode(int val) {
        this.val = val;
    }
}*/
//迭代法
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode p;
        if (list1 == null) return list2;
        if (list2 == null) return list1;
        p = list1;
        if (list2.val < list1.val) { //list1指向头节点较小的链表
            list1 = list2;
            list2 = p;
        }
        p = list1;
        while (p!= null && list2 != null) {
            while (p.next != null && p.next.val <= list2.val) {
                p = p.next;
            }
            ListNode tmp = p.next;
            p.next = list2;
            list2 = tmp;
        }
        return list1;
    }
}
//递归
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if (list1 == null) return list2;
        if (list2 == null) return list1;
        if (list1.val <= list2.val) {
            list1.next = Merge(list1.next, list2);
            return list1;
        } else {
            list2.next = Merge(list2.next, list1);
            return list2;
        }
    }
}

题目描述
从上往下打印出二叉树的每个节点，同层节点从左至右打印。
import java.util.ArrayList;
import java.util.ArrayDeque;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<>();
        if (root == null) return res;
        ArrayDeque<TreeNode> stack = new ArrayDeque<>();
        stack.add(root);
        while (!stack.isEmpty()) {
            int count = stack.size();
            while (count -- > 0) {
                TreeNode node = stack.poll();
                res.add(node.val);
                if (node.left != null) stack.add(node.left);
                if (node.right != null) stack.add(node.right);
            }
        }
        return res;
    }
}

题目描述
输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
public class Solution {
    public int TreeDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(TreeDepth(root.left), TreeDepth(root.right)) + 1;
    }
}

题目描述
操作给定的二叉树，将其变换为源二叉树的镜像。
输入描述:
二叉树的镜像定义：源二叉树
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
public class Solution {
    public void Mirror(TreeNode root) {
        if (root == null) return;
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        Mirror(root.left);
        Mirror(root.right);
    }
}

题目描述
请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
//迭代法
public class Solution {
    boolean isSymmetrical(TreeNode pRoot)
    {
        if (pRoot == null) return true;
        return isSame(pRoot.left, pRoot.right);
    }
    boolean isSame(TreeNode t1, TreeNode t2) {
        if (t1 == null && t2 == null) return true;
        if (t1 == null || t2 == null) return false;
        if (t1.val != t2.val) return false;
        Queue<TreeNode> queue1 = new LinkedList<>();
        Queue<TreeNode> queue2 = new LinkedList<>();
        queue1.add(t1);
        queue2.add(t2);
        while (!queue1.isEmpty() && !queue2.isEmpty()) {
            int cnt1 = queue1.size();
            int cnt2 = queue2.size();
            if (cnt1 != cnt2) return false;
            while (cnt1 -- > 0 && cnt2 -- > 0) {
                TreeNode node1 = queue1.poll();
                TreeNode node2 = queue2.poll();
                if (node1.val != node2.val) return false;
                if (node1.left != null) {
                    if (node2.right == null) return false;
                    queue1.add(node1.left);
                    queue2.add(node2.right);
                } else if (node2.right != null) return false;

                if (node1.right != null) {
                    if (node2.left == null) return false;
                    queue1.add(node1.right);
                    queue2.add(node2.left);
                } else if (node2.left != null) return false;
            }
        }
        return true;
    }
}

//递归
boolean isSymmetrical(TreeNode pRoot) {
    if (pRoot == null)
        return true;
    return isSymmetrical(pRoot.left, pRoot.right);
}
boolean isSymmetrical(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null)
        return true;
    if (t1 == null || t2 == null)
        return false;
    if (t1.val != t2.val)
        return false;
    return isSymmetrical(t1.left, t2.right) && isSymmetrical(t1.right, t2.left);
}

题目描述
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
//Integer.bitCount(n);
public class Solution {
    public int NumberOf1(int n) {
        int cnt = 0;
        while (n != 0) {
            cnt++;
            n = (n - 1) & n;
        }
        return cnt;
    }
}

树的子结构
题目描述
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if (root1 == null || root2 == null) return false;
        if (root1.val == root2.val && isSub(root1, root2))
            return true;
        return HasSubtree(root1.left, root2) | HasSubtree(root1.right, root2);
    }
    boolean isSub(TreeNode t1, TreeNode t2) {  //子结构不是子树
        if (t2 == null) return true;
        if (t1 == null) return false;
        if (t1 != null && t1.val != t2.val)
            return false;
        return isSub(t1.left, t2.left) && isSub(t1.right, t2.right);
    }
}

判断序列是否为二叉搜索树的后序遍历
题目描述
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
public class Solution {
    //先根据根节点将序列划分为左右子树，然后递归判断
    public boolean VerifySquenceOfBST(int [] sequence) {
        if (sequence.length == 0) return false;
        return help(sequence, 0, sequence.length - 1);
    }
    public boolean help(int[] sequence, int start, int end) {
        if (end - start <= 1) return true;
        int root = sequence[end];
        int index = -1;
        boolean flag = false;
        for (int i = 0; i <= end; i++) {
            if (!flag && sequence[i] > root) {
                index = i;
                flag = true;
            }
            if (flag && sequence[i] < root) return false;
        }
        if (index <= 0) return help(sequence, start, end - 1);
        else return help(sequence, start, index - 1) & help(sequence, index, end - 1);
    }
}


