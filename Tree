1. 判断两个树的叶子节点序列是否相等。
思路：dfs.分别求出两棵树的叶子值序列，再进行比较。
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        List<Integer> seq1 = new LinkedList<>();
        List<Integer> seq2 = new LinkedList<>();
        preOrder(root1, seq1);
        preOrder(root2, seq2);
        if (seq1.size() != seq2.size()) return false;
        for (int i = 0; i < seq1.size(); i++) {
            if (seq1.get(i) != seq2.get(i)) return false;
        }
        return true;
        
    }
    public void preOrder(TreeNode root, List<Integer> seq) {
        if (root == null) return;
        if (root.left == null && root.right == null) {
            seq.add(root.val);
        }
        preOrder(root.left, seq);
        preOrder(root.right, seq);
    }
}

leetcode104. Maximum Depth of Binary Tree
思路：递归dfs.根节点的最大深度 = max(左孩子的最大深度，右孩子的最大深度）+ 1；
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int depth = 1;
        return depth+Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}

1022. Sum of Root To Leaf Binary Numbers
思路：回溯法。
用一个list存访问过的节点值，先访问左子树，再访问右子树；
访问到叶子节点，根据list计算整数值并加到全局变量sum中，然后list删除最后一位（即回退一步）并返回；
右子树访问完list再删除最后一位（容易忽略）。
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int sum = 0;
    public int sumRootToLeaf(TreeNode root) {

        if (root == null) return 0;
        dfs(root, new LinkedList());
        return sum;
    }
    public void dfs(TreeNode root, LinkedList<Integer> list) {
        if (root == null)return;
        list.add(root.val);
        if (root.left == null && root.right == null) {
            sum += toInt(list);
            // System.out.println(sum);
            list.removeLast();
            return;
        }
        dfs(root.left, list);
        dfs(root.right, list);
        if (list.size() > 0) list.removeLast();
    }
    public int toInt(List<Integer> list) {
        int i = 0; 
        int val = 0;
        for (int n : list) {
            val = 2 * val + n;
        }
        return val;
    }
}

669. Trim a Binary Search Tree
思路：递归dfs.
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
   public TreeNode trimBST(TreeNode root, int L, int R) {
        if(root == null) return null; // Base case
        /*
        * If current node is greater than the Right limit, we will skip this one
        * try to append its left child to the current position
        * Or current is smaller than the Left limit, skip this one, and try to 
        * append its right child to the current position
        */
        if(root.val > R) return trimBST(root.left, L, R); 
        if(root.val < L) return trimBST(root.right, L, R);
        /*
        * Recursively, check current node's left child and right child if they are trimBST subtree already.
        */
        root.left = trimBST(root.left, L, R);
        root.right = trimBST(root.right, L, R);
        // Return the current Node;
        return root;
    }
}

429. N-ary Tree Level Order Traversal
思路：采用一个队列和一个计数器；计数器的值为当前层的节点数；
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val,List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        
        List<List<Integer>> ans = new LinkedList<>();
        Queue<Node> queue = new ArrayDeque<>();
        if (root == null) return ans;
        queue.add(root);
        while (!queue.isEmpty()) {
            int count = queue.size();
            List<Integer> list = new LinkedList<>();
            while (count -- > 0) {
                Node node = queue.poll();
                list.add(node.val);
                for (Node n : node.children) {
                    if (n!= null) queue.add(n);
                }
                
            }
            ans.add(list);
        }
        return ans;
    }
}
