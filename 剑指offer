替换空格
题目描述
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
解题思路：
作为手撕代码的题目，不能调用String.replace(), 如果不要求空间复杂度，可以新开一个StringBuffer,遍历到空格的时候append("%20");
如果只能在原来的字符串数组中修改应该先遍历字符串数组，统计空格的个数x，然后在原来的基础上增加x*2的长度；
public String replaceSpace(StringBuffer str) {
    int P1 = str.length() - 1;
    for (int i = 0; i <= P1; i++) {
        if (str.charAt(i) == ' ')
            str.append(" ");
        int P2 = str.length() - 1;
        while (P1 >= 0 && P2 > P1) {
            char c = str.charAt(P1--);
            if (c == ' ') {
                str.setCharAt(P2--, '0');
                str.setCharAt(P2--, '2');
                str.setCharAt(P2--, '%');
            } else {
                str.setCharAt(P2--, c);
            }
        }
    }
}

逆序打印链表
题目描述
输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
解题思路：头插法，也可用栈来实现
/**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> res = new ArrayList<>();
        if (listNode == null) return res;
        while (listNode != null) {
            res.add(0, listNode.val);
            listNode = listNode.next;
        }
        return res;
    }
}

题目描述：链表中删除重复节点
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ListNode deleteDuplication(ListNode pHead)
    {
        if (pHead == null || pHead.next == null) return pHead;
        ListNode h = pHead;
        if (h.val == h.next.val) { //头节点重复
            ListNode tmp = null;
            while (pHead != null && pHead.val == h.val) {
                tmp = pHead;
                pHead = pHead.next;
            }
            if (pHead == null) return null; //所有节点都相等
            tmp.next = null;
            return (deleteDuplication(pHead));
        }
        h.next = deleteDuplication(pHead.next);//递归删除重复节点
        return h;
    }
}
//迭代法
public class Solution {
    public ListNode deleteDuplication(ListNode pHead)
    {
        if (pHead == null || pHead.next == null) return pHead;
        //头结点重复
        boolean flag = false;
        if (pHead.val == pHead.next.val) {
            flag = true;
        }
        while (pHead.next!= null && flag) {
            while (pHead.next != null && pHead.val == pHead.next.val) {
                pHead = pHead.next;
            }
            pHead = pHead.next;
            if (pHead == null || pHead.next == null) return pHead;
            if (pHead.val == pHead.next.val) {
                flag = true;
            } else {
                break;
            }
        }
        ListNode pre, h;
        pre = pHead;
        h = pre.next;
        while (h != null && h.next != null) {
            if (h.val == h.next.val) {
                while (h.next != null && h.val == h.next.val) {
                    h = h.next;
                }
                pre.next = h.next;
                h = h.next;
            } else {
                pre = h;
                h = h.next;
            }
        }
        return pHead;
    }
}

题目描述：重建二叉树
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if(pre.length == 0 || in.length == 0) return null;
        return reBuildTree(pre,0, pre.length-1, in, 0, in.length - 1);
    }
    //根据二叉树的特点重建，根据先序遍历的根节点将对应的中序遍历分为两半，
    //中序遍历前半部分是左子树，后半部分是右子树；递归调用
    public TreeNode reBuildTree(int[] pre, int ps, int pe, int[] in, int is, int ie) {
        if (ps > pe || is > ie) return null;
        TreeNode node = new TreeNode(pre[ps]);
        int nodeIndex = 0;
        for (int i = is; i <= ie; i++) {
            if (in[i] == pre[ps]) {
                nodeIndex = i;
                break;
            }
        }
        node.left = reBuildTree(pre, ps + 1, ps + nodeIndex - is, in, is, nodeIndex - 1);
        node.right = reBuildTree(pre, ps + nodeIndex - is + 1,pe, in, nodeIndex + 1, ie);
        return node;
    }
}

题目描述
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
import java.util.Stack;
public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();

    public void push(int node) {
        stack1.push(node);
    }

    public int pop() {
        if (!stack2.isEmpty()) return stack2.pop();  //stack2不为空，直接弹出栈顶元素
        while (!stack1.isEmpty()) {  //stack2为空，将stack1的数据逆向复制到stack2
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }
}

题目描述
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
//方法一：顺序遍历，比第一个值小的即为最小值，特殊情况：数组所有值都相等、旋转数组为数组本身，最小值为第一个数。
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if (array.length == 0) return 0;
        for (int i = 1; i < array.length; i++) {
            if (array[i] < array[0]) return array[i];
        }
        return array[0];
    }
}
//方法二：二分法查找（逻辑复杂，运行效率并没有明显提升，或许是因为测试用例太少？数组长度还不够长？）
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if (array.length == 0) return 0;
        if (array[0] < array[array.length -1]) return array[0];  //旋转数组为本身
        //二分法查找
        int index1 = 0;
        int index2 = array.length - 1;
        int midIndex = 0;
        while (array[index1] >= array[index2]) {
            if (index2 - 1 == index1) {
                midIndex = index2;
                break;
            }
            midIndex = (index1 + index2) / 2;
            //左中右皆相等，顺序遍历
            if (array[index1] == array[index2] && array[index1] == array[midIndex]) {
                for (int i = index1; i <= index2; i++) {
                    if (array[i] < array[index1]) return array[i];
                }
            }
            //缩小一半范围
            if (array[midIndex] >= array[index1]) {
                index1 = midIndex;
            } else if (array[midIndex] <= array[index2]) {
                index2 = midIndex;
            }
        }

        return array[midIndex];
    }
}

题目描述
我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
比如n=3时，2*3的矩形块有3种覆盖方法
解题思路：求斐波那契数列，代码略

题目描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
//实际上是求斐波那契数列，f(1) = 1; f(2) = 2; f(n)=f(n-1)+f(n-2)
//当青蛙一次可以跳上1级、2级......n级的时候，f(n)=2^(n-1);
public class Solution {
    public int JumpFloor(int target) {
        if (target <= 1) return 1;
        if (target == 2) return 2;

        int[] dp = new int[target];
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 2; i < target; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[target-1];
    }
}
题目描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
public class Solution {
    public int JumpFloorII(int target) {
        return pow(2, target-1);  //也可以调用Math.pow(2, target-1);
    }

    //整数的幂函数
    public int pow(int base, int e) {
        if (base == 0) return 0;
        if (e == 0) return 1;
        if (e == 1) return  base;
        if (e == 2) return base * base;
        if (e % 2 == 1) {
            int result = pow(base, (e-1)/2);
            return base * result * result;
        } else {
            int result = pow(base, e/2);
            return result * result;
        }
    }
}

题目描述
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
保证base和exponent不同时为0
public class Solution {
    public double Power(double base, int exponent) {
        double res;
        if (exponent == 0) return 1;
        else if (exponent > 0) {
            res = Power(base, (exponent/2));
            return (exponent % 2 == 0) ? (res * res) : (res * res * base);
        } else {
            if (base == 0) return 0;
            exponent = Math.abs(exponent);
            res = Power(base, exponent);
            return 1 / res;
        }
  }
}

链表反转
题目描述
输入一个链表，反转链表后，输出新链表的表头。
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode p,q, next;
        p = null;
        q = head;
        next = q.next;
        while (next != null) {
            q.next = p;
            p = q;
            q = next;
            next = next.next;
        }
        q.next = p;
        return q;
    }
}

题目描述
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
/*
public class ListNode {
    int val;
    ListNode next = null;
    ListNode(int val) {
        this.val = val;
    }
}*/
//迭代法
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode p;
        if (list1 == null) return list2;
        if (list2 == null) return list1;
        p = list1;
        if (list2.val < list1.val) { //list1指向头节点较小的链表
            list1 = list2;
            list2 = p;
        }
        p = list1;
        while (p!= null && list2 != null) {
            while (p.next != null && p.next.val <= list2.val) {
                p = p.next;
            }
            ListNode tmp = p.next;
            p.next = list2;
            list2 = tmp;
        }
        return list1;
    }
}
//递归
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if (list1 == null) return list2;
        if (list2 == null) return list1;
        if (list1.val <= list2.val) {
            list1.next = Merge(list1.next, list2);
            return list1;
        } else {
            list2.next = Merge(list2.next, list1);
            return list2;
        }
    }
}

题目描述
从上往下打印出二叉树的每个节点，同层节点从左至右打印。
import java.util.ArrayList;
import java.util.ArrayDeque;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<>();
        if (root == null) return res;
        ArrayDeque<TreeNode> stack = new ArrayDeque<>();
        stack.add(root);
        while (!stack.isEmpty()) {
            int count = stack.size();
            while (count -- > 0) {
                TreeNode node = stack.poll();
                res.add(node.val);
                if (node.left != null) stack.add(node.left);
                if (node.right != null) stack.add(node.right);
            }
        }
        return res;
    }
}

题目描述
输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
public class Solution {
    public int TreeDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(TreeDepth(root.left), TreeDepth(root.right)) + 1;
    }
}

题目描述
操作给定的二叉树，将其变换为源二叉树的镜像。
输入描述:
二叉树的镜像定义：源二叉树
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
public class Solution {
    public void Mirror(TreeNode root) {
        if (root == null) return;
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        Mirror(root.left);
        Mirror(root.right);
    }
}

题目描述
请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
//迭代法
public class Solution {
    boolean isSymmetrical(TreeNode pRoot)
    {
        if (pRoot == null) return true;
        return isSame(pRoot.left, pRoot.right);
    }
    boolean isSame(TreeNode t1, TreeNode t2) {
        if (t1 == null && t2 == null) return true;
        if (t1 == null || t2 == null) return false;
        if (t1.val != t2.val) return false;
        Queue<TreeNode> queue1 = new LinkedList<>();
        Queue<TreeNode> queue2 = new LinkedList<>();
        queue1.add(t1);
        queue2.add(t2);
        while (!queue1.isEmpty() && !queue2.isEmpty()) {
            int cnt1 = queue1.size();
            int cnt2 = queue2.size();
            if (cnt1 != cnt2) return false;
            while (cnt1 -- > 0 && cnt2 -- > 0) {
                TreeNode node1 = queue1.poll();
                TreeNode node2 = queue2.poll();
                if (node1.val != node2.val) return false;
                if (node1.left != null) {
                    if (node2.right == null) return false;
                    queue1.add(node1.left);
                    queue2.add(node2.right);
                } else if (node2.right != null) return false;

                if (node1.right != null) {
                    if (node2.left == null) return false;
                    queue1.add(node1.right);
                    queue2.add(node2.left);
                } else if (node2.left != null) return false;
            }
        }
        return true;
    }
}

//递归
boolean isSymmetrical(TreeNode pRoot) {
    if (pRoot == null)
        return true;
    return isSymmetrical(pRoot.left, pRoot.right);
}
boolean isSymmetrical(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null)
        return true;
    if (t1 == null || t2 == null)
        return false;
    if (t1.val != t2.val)
        return false;
    return isSymmetrical(t1.left, t2.right) && isSymmetrical(t1.right, t2.left);
}

题目描述
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
//Integer.bitCount(n);
public class Solution {
    public int NumberOf1(int n) {
        int cnt = 0;
        while (n != 0) {
            cnt++;
            n = (n - 1) & n;
        }
        return cnt;
    }
}

树的子结构
题目描述
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if (root1 == null || root2 == null) return false;
        if (root1.val == root2.val && isSub(root1, root2))
            return true;
        return HasSubtree(root1.left, root2) | HasSubtree(root1.right, root2);
    }
    boolean isSub(TreeNode t1, TreeNode t2) {  //子结构不是子树
        if (t2 == null) return true;
        if (t1 == null) return false;
        if (t1 != null && t1.val != t2.val)
            return false;
        return isSub(t1.left, t2.left) && isSub(t1.right, t2.right);
    }
}

二叉搜索树的后序遍历
判断序列是否为二叉搜索树的后序遍历
题目描述
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
public class Solution {
    //先根据根节点将序列划分为左右子树，然后递归判断
    public boolean VerifySquenceOfBST(int [] sequence) {
        if (sequence.length == 0) return false;
        return help(sequence, 0, sequence.length - 1);
    }
    public boolean help(int[] sequence, int start, int end) {
        if (end - start <= 1) return true;
        int root = sequence[end];
        int index = -1;
        boolean flag = false;
        for (int i = 0; i <= end; i++) {
            if (!flag && sequence[i] > root) {
                index = i;
                flag = true;
            }
            if (flag && sequence[i] < root) return false;
        }
        if (index <= 0) return help(sequence, start, end - 1);
        else return help(sequence, start, index - 1) & help(sequence, index, end - 1);
    }
}

序列化二叉树
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    String desStr;
    String Serialize(TreeNode root) {
        if (root == null) return "#";
        return root.val + "," + Serialize(root.left) + "," + Serialize(root.right);
  }
    TreeNode Deserialize(String str) {
        desStr = str;
       int index = desStr.indexOf(",");
        if (index < 0) {
            desStr = "";
            return null;
        } else {
            String nodeStr = desStr.substring(0, index);
            desStr = desStr.substring(index+1);
            if ("#".equals(nodeStr)) return null;
            TreeNode node = new TreeNode(Integer.parseInt(nodeStr));
            node.left = Deserialize(desStr);
            node.right = Deserialize(desStr);
            return node;
        }
  }
}

链表倒数第k个节点
题目描述
输入一个链表，输出该链表中倒数第k个结点。
//双指针法
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if (head == null || k <= 0) return null;
        ListNode p, q;
        p = q = head;
        while (p != null && k-- > 0) {
            p = p.next;
        }
        if (k > 0) return null;
        while (p != null) {
            p = p.next;
            q = q.next;
        }
        return q;
    }
}

二叉树中和为给定值的路径
题目描述
输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
public class Solution {
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        TreeNode h = root;
        ArrayList<Integer> list = new ArrayList<>();
        helper(root, target, list, res);
        return res;
    }
    public void helper(TreeNode root, int target, ArrayList<Integer> list, ArrayList<ArrayList<Integer>> res) {
        if (root == null || root.val > target) {
            return;
        }
        list.add(root.val);
        target = target - root.val;
        if (target == 0 && root.left == null && root.right == null) {
            ArrayList<Integer> l = new ArrayList<>(list.size());
            l = (ArrayList<Integer>)list.clone();
            res.add(l);
        } else {
            helper(root.left, target, list, res);
            helper(root.right, target, list, res);
        }
        list.remove(list.size()-1);
    }
}

复杂链表的复制
题目描述
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。
（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
/*
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
*/
public class Solution {
    public RandomListNode Clone(RandomListNode pHead)
    {
        if (pHead == null) return pHead;
        RandomListNode head, cur;
        //再每个节点后面复制它本身
        cur = pHead;
        while (cur != null) {
            RandomListNode node = new RandomListNode(cur.label);
            node.next = cur.next;
            cur.next = node;
            cur = node.next;
        }
        //复制random
        cur = pHead;
        while (cur != null) {
            RandomListNode p = cur.next;
            if (cur.random!= null) p.random = cur.random.next;
            cur = p.next;
        }
        //拆分
        cur = pHead;
        head = pHead.next;
        while (cur.next != null) {
            RandomListNode p = cur.next;
            cur.next = p.next;
            cur = p;
        }
        return head;
    }
}

二叉搜索树与双向链表
题目描述
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
思路：按照中序遍历的顺序，修改指针
//中序遍历法
public class Solution {
    private TreeNode pre = null;
    private TreeNode head = null;
    public TreeNode Convert(TreeNode pRootOfTree) {
        if( pRootOfTree == null) return null;
        inOrder(pRootOfTree);
        return head;
    }
    public void inOrder(TreeNode node) {
        if (node != null) {
            inOrder(node.left);
            node.left = pre;
            if (pre != null) {
                pre.right = node;
            }
            if (head == null) {
                head = node;
            }
            pre = node;
            inOrder(node.right);
        }
    }
}
字符串的排列
题目描述
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
输入描述:
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
public class Solution {
    public String PrintMinNumber(int [] numbers) {
        if (numbers == null || numbers.length == 0) return "";
        String[] nums = new String[numbers.length];
        int i = 0;
        for (int n : numbers) {
            nums[i++] = n + "";
        }
        Arrays.sort(nums, (s1, s2) -> (s1 + s2).compareTo(s2+s1));
        String res = "";
        for (String s : nums)
            res += s;
        return res;
    }

}

数组中出现次数超过一半的数字
题目描述
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。
由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
思路一：多数投票算法，详情百度
思路二：快排中的partition，每次随机选一个数做比较，小于等于该数的放左边，大于的放右边，返回小于等于该数的个数；调整区间，直到个数为n/2，即该数为中位数;

数组中最小的k个数
题目描述
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
思路一：优先队列
思路二：与上题类似，使用partition操作，直到找到一个数，小于等于它的个数刚好为k个；
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList<Integer> res = new ArrayList<>();
        if (input == null || k <= 0 || input.length == 0 || k > input.length) return res;
        findSmallerKNums(input, k);
        for (int i = 0; i < k; i++) {
            res.add(input[i]);
        }
        return res;
    }
    public void findSmallerKNums(int[] input, int k) {
        int l = 0;
        int h = input.length - 1;
        while (l < h) {
            int j = partition(input, l, h);
            if (j == k)
                break;
            if (j > k) {
                h = j - 1;
            } else {
                l = j + 1;
            }
        }
    }
    public int partition(int[] nums, int l, int h) {
        int x = nums[l];
        int i = l;
        int j = h + 1;
        while (true) {
            while (i != h && nums[++i] < x);
            while (j != l && nums[--j] > x);
            if (i >= j) break;
            swap(nums, i, j);
        }
        swap(nums, l, j);
        return j;
    }
    public void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}


连续子数组的最大和
题目描述
HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？
例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。
思路：动态规划，dp[i]表示以第i个元素为终点的连续子向量的最大和值
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        int n = array.length;
        if (n == 0) return 0;
        int max = array[0];
        int[] dp = new int[array.length];
        dp[0] = max;
        for (int i = 1; i < n; ++i) {
            dp[i] = Math.max(dp[i-1] + array[i], array[i]);
            max = Math.max(max, dp[i]);
        }
        return max;
    }
}

1～n中1出现的次数
题目描述
求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。
ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
思路：https://www.cnblogs.com/lishanlei/p/10707693.html
public class Solution {
    public int NumberOf1Between1AndN_Solution(int n) {
        int count=0;
        int i = 1;
        int cur, low, high;
        while ((n / i) > 0) {
            cur = (n / i) % 10;
            high = n / (i * 10);
            low = n  - n / i * i;
            if (cur == 0) {
                count += high * i;
            } else if(cur == 1) {
                count += high * i + low + 1;
            } else {
                count += (high + 1) * i;
            }
            i *= 10;
        }
        return count;
    }
}


两个链表的第一个公共节点
题目描述
输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        if (pHead1 == null || pHead2 == null) return null;
        ListNode p;
        int len1 = 0;
        int len2 = 0;
        p = pHead1;
        while (p != null) {
            p = p.next;
            len1++;
        }
        p = pHead2;
        while (p != null) {
            p = p.next;
            len2++;
        }
        int c = len1 - len2;
        if (c > 0) {
            while (c-- > 0) {
                pHead1 = pHead1.next;
            }
        } else {
            c = Math.abs(c);
            while (c-- > 0) {
                pHead2 = pHead2.next;
            }
        }
        while (pHead1 != null && pHead2 != null) {
            if (pHead1 == pHead2) return pHead1;
            else {
                pHead1 = pHead1.next;
                pHead2 = pHead2.next;
            }
        }
        return null;
    }
}

第一个只出现一次的字符
题目描述
在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.
思路：hash表计数法
public class Solution {
    public int FirstNotRepeatingChar(String str) {
        if (str.length() == 0) return -1;
        int[] table = new int[26];
        int[] Table = new int[26];
        char[] charArr = str.toCharArray();
        for (char c : charArr) {
            if (c <= 'z' && c >= 'a')
                table[c-'a']++;
            else
                Table[c-'A']++;
        }
        for (int i = 0; i < charArr.length; i++) {
            if (charArr[i] >= 'a' && charArr[i] <= 'z' && table[charArr[i]-'a'] == 1) return i;
            if (charArr[i] >= 'A' && charArr[i] <= 'Z' && Table[charArr[i]-'A'] == 1) return i;
        }
        return -1;
    }
}

数字在排序数组中出现的次数
题目描述
统计一个数字在排序数组中出现的次数。
import java.util.*;
public class Solution {
    public int GetNumberOfK(int [] array , int k) {
        if (array.length == 0) return 0;
        int index = Arrays.binarySearch(array, k);
        if (index < 0) return 0;
        int res = 1;
        for (int i = index - 1; i >= 0; --i) {
            if (array[i] == k) res++;
        }
        for (int i = index + 1; i < array.length; ++i) {
            if (array[i] == k) res++;
        }
        return res;
    }
}

平衡二叉树
题目描述
输入一棵二叉树，判断该二叉树是否是平衡二叉树。
//通过页子节点的最大、最小深度的差值进行判断
public class Solution {
    int maxDep = 0;
    int minDep = 9999;
    boolean res = true;
    public boolean IsBalanced_Solution(TreeNode root) {
        if (root == null) return true;
        dfs(root.left, 1);
        dfs(root.right, 1);
        return res;
    }
    public void dfs(TreeNode root, int d) {
        if (res == false) return;
        if (root == null) {
            maxDep = Math.max(maxDep, d);
            minDep = Math.min(minDep, d);
            if (maxDep - minDep > 1) {
                res = false;
                return;
            }
            return;
        }
        if (root.left == null && root.right == null) {
            maxDep = Math.max(maxDep, d + 1);
            minDep = Math.min(minDep, d + 1);
            if (maxDep - minDep > 1) {
                res = false;
                return;
            }
        }
        if (root.left != null) dfs(root.left, d+1);
        if (root.right != null) dfs(root.right, d+1);
    }
}
//通过递归比较左右子树的高度进行判断
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if (root == null) {
            return true;
        }
        int l = helper(root.left);
        int r = helper(root.right);
        if (l == -1 || r == -1 || Math.abs(l - r) > 1)
            return false;
        return true;
    }
    public int helper(TreeNode root) {  //如果不平衡，返回-1，否则返回子树的高度
        if (root == null)
            return 0;
        int l = helper(root.left);
        int r = helper(root.right);
        if (l == -1 || r == -1 || (Math.abs(l - r) > 1))
            return -1;
        return Math.max(l, r) + 1;
    }
}

把数组排成最小的数
题目描述
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
//使用基数排序的思想
import java.util.ArrayList;
import java.util.*;
public class Solution {
    public String PrintMinNumber(int [] numbers) {
        return fun(numbers);
    }
    public static String fun(int[] nums) {
        StringBuilder sb = new StringBuilder();
        Integer[] arr = new Integer[nums.length];
        for (int i = 0; i < nums.length; ++i) {
            arr[i] = new Integer(nums[i]);
        }
        baseSort(arr);
        for (int n : arr) {
            sb.append(n);
        }
        return sb.toString();
    }
    public static void baseSort(Integer[] nums) {
        Arrays.sort(nums, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                String s1 = String.valueOf(o1);
                String s2 = String .valueOf(o2);
                for (int i = 0; i < Math.max(s1.length(), s2.length()); ++i) {
                    char c1, c2;
                    if (i >= s1.length()) c1 = s1.charAt(0);
                    else c1 = s1.charAt(i);
                    if (i >= s2.length()) c2 = s2.charAt(0);
                    else c2 = s2.charAt(i);
                    if (c1 != c2) return c1 - c2;
                }
                return 0;
            }
        });
    }
}

丑数
题目描述
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if (index <= 6) return index;
        int i2 = 0, i3 = 0, i5 = 0;
        int[] dp = new int[index];
        dp[0] = 1;
        for (int i = 1; i < index ; i++) {
            int next2 = dp[i2] * 2, next3 = dp[i3] * 3, next5 = dp[i5] * 5;
            dp[i] = Math.min(next2, Math.min(next3, next5));
            if (dp[i] == next2)
                i2++;
            if (dp[i] == next3)  //注意：这里不能使用else if，因为存在next2,next3,next5之间相等的情况
                i3++;
            if (dp[i] == next5)
                i5++;
        }
        return dp[index-1];
    }
}

数组中只出现一次的数字
题目描述
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
思路：异或运算可以消除相等的值
public class Solution {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        if (array == null || array.length == 0) {
            num1[0] = num2[0] = 0;
        }
        int x = array[0];
        for (int i = 1; i < array.length; i++) {
            x ^= array[i];
        }
        int k = x;
        int index = 0;
        //找到异或结果中为1的那一位
        while ((k & 1) == 0) {
            k = k >>> 1;
            index++;
        }
        //按照index位划分为0\1两组数据，分别进行异或操作
        num1[0] = num2[0] = 0;
        for (int i : array) {
            if (((i >>> index) & 1) == 0)
                num1[0] ^= i;
            else
                num2[0] ^= i;
        }
    }
}
变形：在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
思路：每个二进制位求和，如果某个二进制位不能被三整除，那么只出现一次的那个数字在这个二进制位上为1
class Solution {
    public int singleNumber(int[] nums) {
        int[] binarySum = new int[32];
        for(int i = 0; i< 32; i++){//求每个二进制位的和
            int sum = 0;
            for(int num : nums){
                sum += (num >>i & 1);
            }
            binarySum[i] = sum;
        }
        int res = 0;
        for (int i = 0; i< 32; i++){
            if(binarySum[i]%3!=0){
                res += 1<<i;
            }
        }
        return res;
    }
}

排序数组中和为S的两个数
题目描述
输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。
输出描述:对应每个测试案例，输出两个数，小的先输出。
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {
         ArrayList<Integer> res = new ArrayList<>();
        if (array.length == 0) return res;
         int l = 0;
        int r = array.length - 1;
        while (l < r) {
            int s = array[l] + array[r];
            if (s == sum) {
                res.add(array[l]);
                res.add(array[r]);
                return res;
            } else if (s > sum) {
                r--;
            } else {
                l++;
            }
        }
        return res;
    }
}

和为S的连续正整数序列
题目描述
输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
/************************dp数组**************************/
import java.util.ArrayList;
import java.util.*;
public class Solution {
    public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        int len = (sum + 1) / 2 + 1;
        int[][] dp = new int[len][len];
        Arrays.fill(dp[0], 0);

        for (int i = 0; i < len; i++) {
            dp[i][0] = 0;
            dp[i][i] = i;
        }
        for (int i = 1; i < len; i++) {
            for (int j = i + 1; j < len ; j++) {
                dp[i][j] = dp[i][j-1] + j;
                if (dp[i][j] == sum) {
                    ArrayList<Integer> list = new ArrayList<>();
                    for (int k = i; k <= j; k++)
                        list.add(k);
                    res.add(list);
                }
            }
        }
        return res;
    }
}
/*********************** 头尾双指针法 *************/
import java.util.ArrayList;
import java.util.*;
public class Solution {
    public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        int l = 1, r = 2;
        int s = 3;
        int len = (sum + 1) / 2;
         while (l < r) {
             if (s == sum) {
                 ArrayList<Integer> list = new ArrayList<>();
                 for (int i = l; i <= r; i++)
                     list.add(i);
                 res.add(list);
                 s -= l;
                 l++;
                 r++;
                 s += r;
             } else if (s < sum) {
                 r++;
                 s += r;
             } else {
                 s -= l;
                 l++;
             }
         }
        return res;
    }
}

字符串循环左移
题目描述
汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。
例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！
public class Solution {
    public String LeftRotateString(String str,int n) {
        if (str == null) return null;
        if (str.length() == 0) return "";
        if (n > str.length()) return LeftRotateString(str, n % str.length());
        String s1 = str.substring(n);
        s1 = s1 + str.substring(0, n);
        return s1;
    }
}

反转单词顺序
题目描述
Input:
"I am a student."
Output:
"student. a am I"
public class Solution {
    public String ReverseSentence(String str) {
        if (str == null || str.length() < 2) return str;
        char[] arr = str.toCharArray();
        int i = 0, j = 0;
        while (j <= arr.length) {
            if (j == arr.length || arr[j] == ' ') {
                reverse(arr, i, j - 1);
                i = j + 1;
            }
            j++;
        }
        reverse(arr, 0, arr.length-1);
        return new String(arr);
    }
    public void reverse(char[] arr, int l, int r) {
        while (l < r) {
            swap(arr, l++, r--);
        }
    }
    public void swap(char[] arr, int l , int r) {
        char c = arr[l];
        arr[l] = arr[r];
        arr[r] = c;
    }
}

不用四则运算求两数之和
题目描述
写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。
//计算机二进制加法实现原理
public class Solution {
    public int Add(int num1,int num2) {
        return num2 == 0 ? num1 : Add(num1 ^ num2, (num1 & num2) << 1);
    }
}

数组逆序对的个数
题目描述
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。
将P对1000000007取模的结果输出。 即输出P%1000000007
输入描述:
题目保证输入的数组中没有的相同的数字
数据范围：
	对于%50的数据,size<=10^4
	对于%75的数据,size<=10^5
	对于%100的数据,size<=2*10^5
public class Solution {
    int[] arr;
    long res = 0;
    public int InversePairs(int [] array) {
        if (array.length == 0) return 0;
        arr = new int[array.length];
        mergeSort(array, 0, array.length - 1);
        return (int) (res % 1000000007);
    }
    public void mergeSort(int[] array, int l, int r) {
        if (l >= r) return;

        int mid = l + (r - l) / 2;
        mergeSort(array, l, mid);
        mergeSort(array, mid+1, r);
        merge(array, l, mid, r);
    }
    public void merge(int[] array, int l, int mid, int r) {
        int L = mid;
        int R = r;
        int i = r;
        while (L >= l && R > mid) {
            if (array[L] <= array[R]) {
                arr[i] = array[R];
                R--;
            } else {
                res += R - mid;
                arr[i] = array[L];
                L--;
            }
            i--;
        }
        if (L == l - 1) {
            while (R > mid) {
                arr[i--] = array[R--];
            }
        }
        if (R == mid) {
            while (L >= l) {
                arr[i--] = array[L--];
            }
        }
        i = l;
        while (i <= r) {
            array[i] = arr[i];
            i++;
        }
    }
}

数组中重复的数字
题目描述
在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。
请找出数组中任意一个重复的数字。
思路：要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。
对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。
public boolean duplicate(int[] nums, int length, int[] duplication) {
    if (nums == null || length <= 0)
        return false;
    for (int i = 0; i < length; i++) {
        while (nums[i] != i) {
            if (nums[i] == nums[nums[i]]) {
                duplication[0] = nums[i];
                return true;
            }
        swap(nums, i, nums[i]);
        }
    }
    return false;
}
private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}

构建乘积数组
题目描述
给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）
public class Solution {
    public int[] multiply(int[] A) {
        if (A == null || A.length == 0) return new int[A.length];
        int len = A.length;
        int[] dp1 = new int[len]; //dp1[i] = A[0] * A[1] * ... * A[i]
        int[] dp2 = new int[len]; //dp2[i] = A[n-1] * A[n-2] * ... * A[i];
        dp1[0] = A[0];
        dp2[len-1] = A[len-1];
        for (int i = 1; i < A.length; i++) {
            dp1[i] = dp1[i-1] * A[i];
        }
        for (int i = len - 2; i >= 0; i--) {
            dp2[i] = dp2[i+1] * A[i];
        }
        int[] B = new int[len];
        B[0] = dp2[1];
        B[len-1] = dp1[len-2];
        for (int i = 1; i < len - 1; i++) {
            B[i] = dp1[i-1] * dp2[i+1];
        }
        return B;
    }
}

二叉树中序遍历的下一个节点
题目描述
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
/*
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if (pNode == null) return null;
        if (pNode.right == null) {
            TreeLinkNode p = pNode.next;
            while (p != null && p.val < pNode.val) {
                p = p.next;
            }
            return p;
        }
        if (pNode.right.left == null) return pNode.right;
        return GetMinInRTree(pNode.right);
    }
    public TreeLinkNode GetMinInRTree(TreeLinkNode pNode) {
        if (pNode == null || pNode.left == null) return pNode;
        return GetMinInRTree(pNode.left);
    }
}

之字形打印二叉树
题目描述
请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
import java.util.ArrayList;
import java.util.*;
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        if (pRoot == null) return res;
        boolean reverse = false;
        Deque<TreeNode> stack = new ArrayDeque<>();
        stack.add(pRoot);
        int i = 1;
        while (!stack.isEmpty()) {
            int count = stack.size();
            ArrayList<Integer> list = new ArrayList<>();
            while (count-- > 0) {
                TreeNode node = stack.poll();
                list.add(node.val);
                if (node.left != null) stack.add(node.left);
                if (node.right != null) stack.add(node.right);
            }
            if (reverse) {
                Collections.reverse(list);
            }
            reverse = !reverse;
            res.add(list);
            i++;
        }
        return res;
    }
}

圆圈中最后剩下的数字
题目描述：0,1, ... ,n-1这n个数字排成一个圈，从0开始，每次从圈里删除第m个数字，求最后一个数字，不存在，则返回-1。
思路一：循环链表，复杂度O(mn)
思路二：数学方法， fn = (fn-1 + m) % n;
class Node {
    int val;
    Node next;
    public Node(int v) {
        this.val = v;
        this.next = null;
    }
}
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        if (n < 1 || m < 1) return -1;
        Node head = new Node(0);
        Node p = head;
        for (int i = 1; i < n; i++) {
            Node node = new Node(i);
            p.next = node;
            p = p.next;
        }
        p.next = head;
        int i = 0;
        while (n > 1) {
            if (i == m - 1) {
                p.next = head.next;
                head.next = null;
                head = p.next;
                i = 0;
                n--;
            }
            i++;
            p = head;
            head = head.next;
        }
        return p.val;
    }
}

public int LastRemaining_Solution(int n, int m) {
    if (n == 0) /* 特殊输入的处理 */
        return -1;
    if (n == 1) /* 递归返回条件 */
        return 0;
    return (LastRemaining_Solution(n - 1, m) + m) % n;
}

扑克牌顺子
思路：先用boolean数组标记出现的数字，统计0的个数和最小与最大之间缺失的个数，进行比较
public class Solution {
    public boolean isContinuous(int [] numbers) {
        if (numbers == null || numbers.length < 5) return false;
        boolean[] vis = new boolean[14];
        int begin;
        int end;
        int zeroCnt = 0;
        for (int n : numbers) {
            if (n == 0) {
                zeroCnt++;
                continue;
            }
            if (vis[n]) return false;
            vis[n] = true;
        }
        int i = 1;
        while (i < 13 && !vis[i]) {
            i++;
        }
        begin = i;
        i = 13;
        while (i > begin && !vis[i]) {
            i--;
        }
        end = i;
        for (i = begin; i <= end; i++) {
            if (!vis[i]) zeroCnt--;
        }
        return (zeroCnt >= 0);
    }
}

1～n求和
题目描述
求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
思路：使用&&（短路与）代替if判断
public class Solution {
    public int Sum_Solution(int n) {
        int sum = n;
        boolean b= (n > 0) && ((sum += Sum_Solution(n - 1)) > 0);
        return sum;
    }
}

剪绳子
题目描述
给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？
例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
public class Solution {  //动态规划
    public int cutRope(int target) {
        if (target < 2) return 0;
        else if (target == 2) return 1;
        else if (target == 3) return 2;
        int[] dp = new int[target+1];
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;
        for (int i = 4; i <= target; ++i) {
            int max = 0;
            for (int j = 1; j <= i / 2; ++j) {
                max = dp[i] = Math.max(dp[j] * dp[i-j], max);
            }
        }
        return dp[target];
    }
}
public class Solution { //贪心
    public int cutRope(int target) {
        if (target < 2) return 0;
        else if (target == 2) return 1;
        else if (target == 3) return 2;
        int times3 = target / 3;
        if (target - times3 * 3 ==1) times3--;
        int times2 = (target - times3 * 3) / 2;
        return (int)Math.pow(3, times3) * (int)Math.pow(2, times2);
    }
}

滑动窗口最大值
题目描述
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}；
针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] num, int size)
    {
        ArrayList<Integer> res = new ArrayList<>();
        if (num == null || num.length == 0 || size == 0 || size > num.length) return res;
        PriorityQueue<Integer> queue = new PriorityQueue<>(size, new Comparator<Integer>() {
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        });
        int l = 0;
        int r = 0;
        while (r < size) {
            queue.offer(num[r++]);
        }
        res.add(queue.peek());
        while (r < num.length) {
            queue.offer(num[r++]);
            l++;
            queue.remove(num[l-1]);
            res.add(queue.peek());
        }
        return res;
    }
}

矩阵路径
题目描述
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。
如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。
思路：回溯法
public class Main {
    boolean[][] vis;
    char[][] matrix;
    int r, c;
    HashSet<Character> set;
    boolean res = false;
    public boolean hasPath(char[] mat, int rows, int cols, char[] str)
    {
        if (str.length == 0 || mat.length == 0) return false;
        this.r = rows;
        this.c = cols;
        vis = new boolean[r][c];
        set = new HashSet<>();
        matrix = new char[r][c];
        for (char c : str) {
            set.add(c);
        }
        for (int i = 0; i < r; ++i) {
            for (int j = 0; j < c; ++j) {
                matrix[i][j] = mat[i*cols+j];
                System.out.print(matrix[i][j] + "  ");
                if (!set.contains(matrix[i][j]))
                    vis[i][j] = true;
            }
            System.out.println();
        }
        for (int i = 0; i < r && !res; ++i) {
            for (int j = 0; j < c && !res; ++j)
                dfs(i, j, str, 0);
        }
        return res;
    }
    public void dfs(int rows, int cols, char[] str, int point) {
        if (rows < 0 || rows >= r || cols < 0 || cols >= c || vis[rows][cols] || res) return;
        vis[rows][cols] = true;
        if (matrix[rows][cols] != str[point]) {
            vis[rows][cols] = false;
            return;
        }
        if (point == str.length - 1) {
            res = true;
            return;
        }
        System.out.println("cur matrix: " + matrix[rows][cols]);
        System.out.println("cur str: " + str[point]);
        dfs(rows, cols - 1, str, point + 1);
        dfs(rows, cols + 1, str, point + 1);
        dfs(rows - 1, cols, str, point + 1);
        dfs(rows + 1, cols, str, point + 1);
        vis[rows][cols] = false;
        point--;
    }
    public static void main(String[] args) {
        char[] mat = "ABCESFCSADEE".toCharArray();
        char[] str = "ABCB".toCharArray();
        System.out.println(new Main().hasPath(mat, 3, 4, str));
    }
}
机器人的活动范围
题目描述
地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。
例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？
public class Solution {
    int count = 0;
    int r, c, k;
    boolean[][] vis;  //记录遍历过的位置
    int[][] digitSum;  //避免重复计算，将结果存在数组
    public int movingCount(int threshold, int rows, int cols)
    {
        k = threshold;
        r = rows;
        c = cols;
        vis = new boolean[r][c];
        digitSum = new int[r][c];
        initDigitSum();
        dfs(0, 0);
        return count;
    }
    public void dfs(int i, int j) {
        if (i < 0 || i >= r || j < 0 || j >= c || vis[i][j]) return;
        vis[i][j] = true;
        count++;
        dfs(i - 1, j);
        dfs(i, j - 1);
        dfs(i, j + 1);
        dfs(i + 1, j);
    }
    private void initDigitSum() {
        int n = Integer.max(r, c);
        int[] dig = new int[n];
        for (int i = 0; i < n; ++i) {
            dig[i] = digSum(i);
        }
        for (int i = 0; i < r; ++i) {
            for (int j = 0; j < c; ++j) {
                digitSum[i][j] = dig[i] + dig[j];
                if (digitSum[i][j] > k) vis[i][j] = true;  //在求和的时候直接过滤掉不符合的点
            }
        }
    }
    public int digSum(int a) {
        int sum = 0;
        while (a != 0) {
            sum += a % 10;
            a /= 10;
        }
        return sum;
    }
}