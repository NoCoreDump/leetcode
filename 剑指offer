题目描述：链表中删除重复节点
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ListNode deleteDuplication(ListNode pHead)
    {
        if (pHead == null || pHead.next == null) return pHead;
        ListNode h = pHead;
        if (h.val == h.next.val) { //头节点重复
            ListNode tmp = null;
            while (pHead != null && pHead.val == h.val) {
                tmp = pHead;
                pHead = pHead.next;
            }
            if (pHead == null) return null; //所有节点都相等
            tmp.next = null;
            return (deleteDuplication(pHead));
        }
        h.next = deleteDuplication(pHead.next);//递归删除重复节点
        return h;
    }
}

题目描述：重建二叉树
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    int[] pre, in;
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        this.pre = pre;
        this.in = in;
        if (pre.length == 0) return null;
        TreeNode root = help(0, pre.length-1, 0, pre.length-1);
        return root;
    }
    //根据二叉树的特点重建，根据先序遍历的根节点将对应的中序遍历分为两半，
    //中序遍历前半部分是左子树，后半部分是右子树；递归调用
    public TreeNode help(int i, int j, int m, int n) {
        TreeNode node = null;
        if (j >= pre.length || n >= pre.length) return null;
        if (i < 0 || m < 0) return null;
        for (int k = m; k <= n; k++){
            if (pre[i] == in[k]) {
                node = new TreeNode((pre[i]));
                node.left = help(i+1, i+k-m, m, k-1);
                node.right = help(i+k-m+1,j,k+1,n);
                break;
            }
        }
        
        return node;
    }
}

题目描述
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();

    public void push(int node) {
        stack1.push(node);
    }

    public int pop() {
        if (!stack2.isEmpty()) return stack2.pop();  //stack2不为空，直接弹出栈顶元素
        while (!stack1.isEmpty()) {  //stack2为空，将stack1的数据逆向复制到stack2
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }
}

题目描述
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。


//方法一：顺序遍历，比第一个值小的即为最小值，特殊情况：数组所有值都相等、旋转数组为数组本身，最小值为第一个数。
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if (array.length == 0) return 0;
        for (int i = 1; i < array.length; i++) {
            if (array[i] < array[0]) return array[i];
        }
        return array[0];
    }
}
//方法二：二分法查找（逻辑复杂，运行效率并没有明显提升，或许是因为测试用例太少？数组长度还不够长？）
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if (array.length == 0) return 0;
        if (array[0] < array[array.length -1]) return array[0];  //旋转数组为本身
        //二分法查找
        int index1 = 0;
        int index2 = array.length - 1;
        int midIndex = 0;
        while (array[index1] >= array[index2]) {
            if (index2 - 1 == index1) {
                midIndex = index2;
                break;
            }
            midIndex = (index1 + index2) / 2;
            //左中右皆相等，顺序遍历
            if (array[index1] == array[index2] && array[index1] == array[midIndex]) {
                for (int i = index1; i <= index2; i++) {
                    if (array[i] < array[index1]) return array[i];
                }
            }
            //缩小一半范围
            if (array[midIndex] >= array[index1]) {
                index1 = midIndex;
            } else if (array[midIndex] <= array[index2]) {
                index2 = midIndex;
            }
        }

        return array[midIndex];
    }
}

题目描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
//实际上是求斐波那契数列，f(1) = 1; f(2) = 2; f(n)=f(n-1)+f(n-2)
//当青蛙一次可以跳上1级、2级......n级的时候，f(n)=2^(n-1);
public class Solution {
    public int JumpFloor(int target) {
        if (target <= 1) return 1;
        if (target == 2) return 2;

        int[] dp = new int[target];
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 2; i < target; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[target-1];
    }
}
题目描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
public class Solution {
    public int JumpFloorII(int target) {
        if (target== 1) return 1;
        if (target== 2) return 2;
        return pow(2, target-1);
    }

    //整数的幂函数
    public int pow(int base, int e) {
        if (base == 0) return 0;
        if (e == 0) return 1;
        if (e == 1) return  base;
        if (e == 2) return base * base;
        if (e % 2 == 1) {
            int result = pow(base, (e-1)/2);
            return base * result * result;
        } else {
            int result = pow(base, e/2);
            return result * result;
        }
    }
}

